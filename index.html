
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Cropping Tool</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD for standalone usage) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel Standalone (to compile JSX in browser) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      /* Custom scrollbar for better aesthetics */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1f2937; 
      }
      ::-webkit-scrollbar-thumb {
        background: #4b5563; 
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6b7280; 
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useCallback, useRef } = React;

      // --- Configuration ---
      const APP_VERSION = 'ver. 20260119.01';

      const SCALE_PRESETS = [0.5, 1, 1.5, 2, 2.5];

      // We now define PRESETS with base dimensions for aspect ratio calculation
      const CROP_PRESETS = [
        { 
            id: 'mobile',
            label: 'Mobile',
            baseWidth: 1055, 
            baseHeight: 967,
            suffix: '_S'
        },
        { 
            id: 'desktop',
            label: 'Desktop',
            baseWidth: 1024, 
            baseHeight: 440,
            suffix: '_L'
        },
      ];

      const PREVIEW_WIDTH = 450;

      // --- Icons ---
      const DownloadIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>
      );

      const RefreshIcon = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h5m11 2a9 9 0 11-2-7.89M20 4v5h-5" />
        </svg>
      );

      // --- ImageUploader Component ---
      const ImageUploader = ({ onImageUpload }) => {
        const inputRef = useRef(null);

        const handleFileChange = (event) => {
          const file = event.target.files?.[0];
          if (file && file.type.startsWith('image/')) {
            onImageUpload(file);
          }
        };

        const handleDrop = useCallback((event) => {
          event.preventDefault();
          event.stopPropagation();
          event.currentTarget.classList.remove('border-indigo-400');
          const file = event.dataTransfer.files?.[0];
          if (file && file.type.startsWith('image/')) {
            onImageUpload(file);
          }
        }, [onImageUpload]);

        const handleDragOver = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        const handleDragEnter = (event) => {
          event.currentTarget.classList.add('border-indigo-400');
        };

        const handleDragLeave = (event) => {
          event.currentTarget.classList.remove('border-indigo-400');
        };

        return (
          <div className="w-full">
            <label
              onDrop={handleDrop}
              onDragOver={handleDragOver}
              onDragEnter={handleDragEnter}
              onDragLeave={handleDragLeave}
              className="flex flex-col items-center justify-center w-full h-64 px-4 transition bg-gray-800 border-2 border-gray-600 border-dashed rounded-md cursor-pointer hover:border-gray-400 focus:outline-none"
            >
              <span className="flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" className="w-10 h-10 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                  <path strokeLinecap="round" strokeLinejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                </svg>
              </span>
              <span className="font-medium text-gray-400 mt-4 text-center">
                Drop your image here, or
                <span className="text-indigo-400 underline ml-1">browse</span>
              </span>
              <input type="file" name="file_upload" className="hidden" accept="image/*" onChange={handleFileChange} ref={inputRef} />
            </label>
          </div>
        );
      };

      // --- CropPreview Component ---
      const CropPreview = ({ 
        imageInfo, 
        target, 
        position, 
        onPositionChange, 
        layout, 
        zoom, 
        onZoomChange,
        scale,
        onScaleChange
      }) => {
        const [isDragging, setIsDragging] = useState(false);
        const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

        const { container, image } = layout;

        const clampPosition = useCallback((pos) => {
          const minX = container.width - image.width;
          const minY = container.height - image.height;
          
          return {
            x: Math.min(0, Math.max(minX, pos.x)),
            y: Math.min(0, Math.max(minY, pos.y)),
          };
        }, [container.width, container.height, image.width, image.height]);

        const handleMouseDown = (e) => {
          e.preventDefault();
          setIsDragging(true);
          setDragStart({
            x: e.clientX - position.x,
            y: e.clientY - position.y,
          });
        };

        const handleMouseMove = useCallback((e) => {
          if (!isDragging) return;
          const newPos = {
            x: e.clientX - dragStart.x,
            y: e.clientY - dragStart.y,
          };
          onPositionChange(target.id, clampPosition(newPos));
        }, [isDragging, dragStart, onPositionChange, target.id, clampPosition]);

        const handleMouseUp = useCallback(() => {
          setIsDragging(false);
        }, []);

        useEffect(() => {
          if (isDragging) {
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
          }
          return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
          };
        }, [isDragging, handleMouseMove, handleMouseUp]);

        return (
          <div className="flex flex-col items-center">
            <div className="flex items-center gap-2 mb-3">
              <span className="px-3 py-1 bg-indigo-900 text-indigo-100 text-sm font-bold rounded-full border border-indigo-700">
                {target.label ? `${target.label} : ` : ''}{target.width} × {target.height}
              </span>
            </div>
            
            {/* Container */}
            <div
              className="relative bg-gray-800 border-4 border-gray-700 cursor-move overflow-hidden rounded-lg shadow-2xl group"
              style={{ width: container.width, height: container.height }}
              onMouseDown={handleMouseDown}
              onMouseLeave={handleMouseUp}
            >
              {/* Overlay Instruction */}
              <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black/20 pointer-events-none z-10">
                <span className="text-white drop-shadow-md text-sm font-semibold bg-black/50 px-2 py-1 rounded">
                  Drag to Pan
                </span>
              </div>

              {/* Image */}
              <img
                src={imageInfo.src}
                alt="Crop preview"
                className="absolute max-w-none select-none"
                style={{
                  width: image.width,
                  height: image.height,
                  transform: `translate(${position.x}px, ${position.y}px)`,
                  willChange: 'transform',
                  imageRendering: 'high-quality'
                }}
                draggable="false"
              />
            </div>

            <div className="w-full mt-4 bg-gray-800 p-3 rounded-lg border border-gray-700 space-y-3">
                {/* Zoom Control */}
                <div className="flex items-center justify-between gap-4">
                  <span className="text-xs font-semibold text-gray-400 uppercase tracking-wider w-12">Zoom</span>
                  <input 
                      type="range" 
                      min="1" 
                      max="2" 
                      step="0.01" 
                      value={zoom} 
                      onChange={(e) => onZoomChange(parseFloat(e.target.value))}
                      className="flex-1 h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-indigo-500 hover:accent-indigo-400"
                  />
                  <span className="text-sm font-mono text-indigo-300 w-12 text-right">{zoom.toFixed(1)}x</span>
                </div>

                {/* Scale Control */}
                <div className="flex items-center justify-between gap-4">
                   <span className="text-xs font-semibold text-gray-400 uppercase tracking-wider w-12">Ratio</span>
                   <div className="flex-1 flex justify-between gap-1">
                      {SCALE_PRESETS.map((s) => (
                        <button
                          key={s}
                          onClick={() => onScaleChange(s)}
                          className={`flex-1 text-[10px] sm:text-xs py-1 px-1 rounded transition-colors ${
                            scale === s 
                              ? 'bg-indigo-600 text-white font-bold shadow-sm' 
                              : 'bg-gray-700 text-gray-400 hover:bg-gray-600'
                          }`}
                        >
                          {s}x
                        </button>
                      ))}
                   </div>
                   <span className="w-12"></span> {/* Spacer for alignment */}
                </div>
            </div>
          </div>
        );
      };

      // --- Main App Component ---
      const App = () => {
        const [imageInfo, setImageInfo] = useState(null);
        // State to store the calculated crop targets for the current image
        const [dynamicTargets, setDynamicTargets] = useState([]);
        const [cropPositions, setCropPositions] = useState({});
        const [zoomLevels, setZoomLevels] = useState({});
        const [targetScales, setTargetScales] = useState({});
        // Changed state to store object with url and size
        const [croppedImages, setCroppedImages] = useState({});
        const [isProcessing, setIsProcessing] = useState(false);
        const [quality, setQuality] = useState(0.92);

        useEffect(() => {
          return () => {
            Object.values(croppedImages).forEach(img => URL.revokeObjectURL(img.url));
          };
        }, [croppedImages]);

        // Utility to format file size
        const formatFileSize = (bytes) => {
          if (bytes === 0) return '0 Bytes';
          const k = 1024;
          const sizes = ['Bytes', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        };

        const calculateLayout = useCallback((target, imgInfo) => {
          const targetRatio = target.width / target.height;
          const containerWidth = PREVIEW_WIDTH;
          const containerHeight = containerWidth / targetRatio;

          const imageRatio = imgInfo.width / imgInfo.height;
          
          let renderWidth;
          let renderHeight;

          if (imageRatio > targetRatio) {
            renderHeight = containerHeight;
            renderWidth = renderHeight * imageRatio;
          } else {
            renderWidth = containerWidth;
            renderHeight = renderWidth / imageRatio;
          }

          const scaleFactor = imgInfo.width / renderWidth;

          return {
            container: { width: containerWidth, height: containerHeight },
            image: { width: renderWidth, height: renderHeight },
            scaleFactor: scaleFactor,
          };
        }, []);

        const handleImageUpload = useCallback((file) => {
          resetState();
          const fileName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
          const reader = new FileReader();
          reader.onload = (e) => {
            const src = e.target?.result;
            const img = new Image();
            img.onload = () => {
              const imgW = img.naturalWidth;
              const imgH = img.naturalHeight;

              const newImageInfo = { 
                  src, 
                  element: img, 
                  width: imgW, 
                  height: imgH,
                  name: fileName,
                  size: file.size
              };
              setImageInfo(newImageInfo);
              
              // --- Calculate Dynamic Targets based on Aspect Ratio and Image Size ---
              const newTargets = CROP_PRESETS.map(preset => {
                  const ratio = preset.baseWidth / preset.baseHeight;
                  
                  // Attempt to fit by width (Width = Image Width)
                  let targetW = imgW;
                  let targetH = imgW / ratio;

                  // If height exceeds image height, fit by height (Height = Image Height)
                  // This ensures we get the max resolution within strict aspect ratio without upscaling
                  if (targetH > imgH) {
                      targetH = imgH;
                      targetW = imgH * ratio;
                  }

                  return {
                      id: preset.id,
                      label: preset.label,
                      suffix: preset.suffix,
                      width: Math.floor(targetW),
                      height: Math.floor(targetH)
                  };
              });
              setDynamicTargets(newTargets);

              const initialZooms = newTargets.reduce((acc, target) => {
                  acc[target.id] = 1;
                  return acc;
              }, {});
              setZoomLevels(initialZooms);
              
              const initialScales = newTargets.reduce((acc, target) => {
                  acc[target.id] = 1;
                  return acc;
              }, {});
              setTargetScales(initialScales);

              const initialPositions = newTargets.reduce((acc, target) => {
                const layout = calculateLayout(target, newImageInfo);
                acc[target.id] = {
                  x: (layout.container.width - layout.image.width) / 2,
                  y: (layout.container.height - layout.image.height) / 2,
                };
                return acc;
              }, {});
              setCropPositions(initialPositions);
            };
            img.src = src;
          };
          reader.readAsDataURL(file);
        }, [calculateLayout]);

        const resetState = () => {
          setImageInfo(null);
          setDynamicTargets([]);
          setCropPositions({});
          setZoomLevels({});
          setTargetScales({});
          Object.values(croppedImages).forEach(img => URL.revokeObjectURL(img.url));
          setCroppedImages({});
          setIsProcessing(false);
          setQuality(0.92);
        };

        const handlePositionChange = (id, newPosition) => {
          setCropPositions(prev => ({ ...prev, [id]: newPosition }));
        };

        const handleZoomChange = (id, newZoom) => {
          if (!imageInfo) return;
          const target = dynamicTargets.find(t => t.id === id);
          if (!target) return;

          const oldZoom = zoomLevels[id] || 1;
          const layout = calculateLayout(target, imageInfo);
          const pos = cropPositions[id] || { x: 0, y: 0 };

          const containerCenter = { x: layout.container.width / 2, y: layout.container.height / 2 };
          const offsetFromImageOrigin = { 
              x: containerCenter.x - pos.x, 
              y: containerCenter.y - pos.y 
          };

          const scaleChange = newZoom / oldZoom;
          const newOffset = {
              x: offsetFromImageOrigin.x * scaleChange,
              y: offsetFromImageOrigin.y * scaleChange
          };

          let newX = containerCenter.x - newOffset.x;
          let newY = containerCenter.y - newOffset.y;

          const zoomedWidth = layout.image.width * newZoom;
          const zoomedHeight = layout.image.height * newZoom;
          const minX = layout.container.width - zoomedWidth;
          const minY = layout.container.height - zoomedHeight;

          newX = Math.min(0, Math.max(minX, newX));
          newY = Math.min(0, Math.max(minY, newY));

          setZoomLevels(prev => ({ ...prev, [id]: newZoom }));
          setCropPositions(prev => ({ ...prev, [id]: { x: newX, y: newY } }));
        };
        
        const handleScaleChange = (id, newScale) => {
          setTargetScales(prev => ({ ...prev, [id]: newScale }));
        };

        const handleCrop = async () => {
          if (!imageInfo) return;
          setIsProcessing(true);

          const cropPromises = dynamicTargets.map(target =>
            new Promise((resolve, reject) => {
              try {
                const canvas = document.createElement('canvas');
                
                // Get the current scale selected by user (default 1)
                const scale = targetScales[target.id] || 1;
                const outputWidth = Math.round(target.width * scale);
                const outputHeight = Math.round(target.height * scale);
                
                canvas.width = outputWidth;
                canvas.height = outputHeight;
                const ctx = canvas.getContext('2d');
                if (!ctx) return reject(new Error('Failed to get canvas context'));

                // High quality settings
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                const layout = calculateLayout(target, imageInfo);
                const zoom = zoomLevels[target.id] || 1;
                const position = cropPositions[target.id];

                const renderedWidth = layout.image.width * zoom;
                const finalScaleFactor = imageInfo.width / renderedWidth;
                
                const sourceX = Math.abs(position.x) * finalScaleFactor;
                const sourceY = Math.abs(position.y) * finalScaleFactor;

                const sourceWidth = layout.container.width * finalScaleFactor;
                const sourceHeight = layout.container.height * finalScaleFactor;

                ctx.drawImage(
                  imageInfo.element,
                  Math.round(sourceX),
                  Math.round(sourceY),
                  Math.round(sourceWidth),
                  Math.round(sourceHeight),
                  0,
                  0,
                  outputWidth,
                  outputHeight
                );

                canvas.toBlob(blob => {
                  if (blob) {
                    resolve({
                        id: target.id, 
                        result: {
                            url: URL.createObjectURL(blob),
                            size: blob.size
                        }
                    });
                  } else {
                    reject(new Error('Failed to create blob'));
                  }
                }, 'image/webp', quality); 
              } catch (error) {
                reject(error);
              }
            })
          );

          try {
            const results = await Promise.all(cropPromises);
            // Transform array back to object keyed by ID
            const newCroppedImages = results.reduce((acc, item) => {
                acc[item.id] = item.result;
                return acc;
            }, {});
            setCroppedImages(newCroppedImages);
          } catch (error) {
            console.error("Cropping failed:", error);
            alert("An error occurred during cropping. Please check the console.");
          } finally {
              setIsProcessing(false);
          }
        };

        const getOutputFilename = (baseName, target, scale) => {
            const w = Math.round(target.width * scale);
            const h = Math.round(target.height * scale);
            if (target.suffix) {
                return `${baseName}${target.suffix}_${w}x${h}.webp`;
            }
            return `${baseName}_${w}x${h}.webp`;
        };

        return (
          <div className="min-h-screen relative bg-gray-900 text-gray-200 font-sans p-4 sm:p-8">
            <div className="absolute top-2 right-2 sm:top-4 sm:right-4 text-xs text-gray-600 font-mono pointer-events-none select-none">
              {APP_VERSION}
            </div>
            <div className="max-w-7xl mx-auto">
              <header className="text-center mb-8">
                <h1 className="text-4xl font-bold text-white tracking-tight">Image Cropping Tool</h1>
                <p className="text-lg text-gray-400 mt-2">Upload an image, pan and zoom to adjust crop, and export as WebP.</p>
              </header>

              <main>
                {!imageInfo ? (
                  <div className="max-w-lg mx-auto">
                    <ImageUploader onImageUpload={handleImageUpload} />
                  </div>
                ) : (
                  <div>
                    {/* File Info Block */}
                    <div className="flex flex-col sm:flex-row items-center justify-between max-w-4xl mx-auto mb-10 bg-gray-800 p-5 rounded-xl border border-gray-700 shadow-xl">
                      <div className="flex items-center space-x-4 mb-4 sm:mb-0 w-full sm:w-auto overflow-hidden">
                        <div className="p-3 bg-gray-700 rounded-lg shrink-0">
                           <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-indigo-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                           </svg>
                        </div>
                        <div className="min-w-0">
                          <p className="text-xs text-gray-400 font-bold uppercase tracking-wider mb-0.5">File Name</p>
                          <h3 className="text-lg font-bold text-white truncate" title={imageInfo.name}>{imageInfo.name}</h3>
                        </div>
                      </div>
                      
                      <div className="flex items-center justify-start sm:justify-end w-full sm:w-auto pl-0 sm:pl-4 border-t sm:border-t-0 sm:border-l border-gray-700 pt-4 sm:pt-0 gap-8">
                          <div className="text-left sm:text-right">
                             <p className="text-xs text-gray-400 font-bold uppercase tracking-wider mb-0.5">File Size</p>
                             <p className="text-lg font-mono font-bold text-indigo-300">{formatFileSize(imageInfo.size)}</p>
                          </div>
                          <div className="text-left sm:text-right">
                             <p className="text-xs text-gray-400 font-bold uppercase tracking-wider mb-0.5">Original Size</p>
                             <p className="text-lg font-mono font-bold text-indigo-300">{imageInfo.width} × {imageInfo.height} <span className="text-sm text-gray-500 font-sans font-normal">px</span></p>
                          </div>
                      </div>
                    </div>

                    <div className="flex flex-col xl:flex-row gap-12 mb-12 justify-center items-start">
                      {dynamicTargets.map(target => {
                        const baseLayout = calculateLayout(target, imageInfo);
                        const currentZoom = zoomLevels[target.id] || 1;
                        const currentScale = targetScales[target.id] || 1;

                        const displayLayout = {
                          container: baseLayout.container,
                          image: {
                              width: baseLayout.image.width * currentZoom,
                              height: baseLayout.image.height * currentZoom
                          }
                        };
                        
                        // Calculated target for display purposes
                        const displayTarget = {
                            ...target,
                            width: Math.round(target.width * currentScale),
                            height: Math.round(target.height * currentScale)
                        };

                        return (
                          <CropPreview
                            key={target.id}
                            imageInfo={imageInfo}
                            target={displayTarget}
                            position={cropPositions[target.id] || { x: 0, y: 0 }}
                            onPositionChange={handlePositionChange}
                            layout={displayLayout}
                            zoom={currentZoom}
                            onZoomChange={(z) => handleZoomChange(target.id, z)}
                            scale={currentScale}
                            onScaleChange={(s) => handleScaleChange(target.id, s)}
                          />
                        );
                      })}
                    </div>

                    <div className="w-full max-w-md mx-auto mb-8 bg-gray-800 p-4 rounded-lg border border-gray-700 shadow-lg">
                      <div className="flex items-center justify-between gap-4 mb-2">
                        <span className="text-sm font-semibold text-gray-300 uppercase tracking-wide">Output Quality (WebP)</span>
                        <span className="text-sm font-mono text-indigo-300 font-bold">{Math.round(quality * 100)}%</span>
                      </div>
                      <input 
                        type="range" 
                        min="0.1" 
                        max="1" 
                        step="0.01" 
                        value={quality} 
                        onChange={(e) => setQuality(parseFloat(e.target.value))}
                        className="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-indigo-500 hover:accent-indigo-400"
                      />
                    </div>

                    <div className="flex flex-col sm:flex-row items-center justify-center gap-4 mb-8">
                      <button
                        onClick={handleCrop}
                        disabled={isProcessing}
                        className="w-full sm:w-auto flex items-center justify-center gap-2 px-8 py-4 bg-indigo-600 text-white font-bold text-lg rounded-lg shadow-lg hover:bg-indigo-700 disabled:bg-indigo-400 disabled:cursor-not-allowed transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-indigo-500"
                      >
                        {isProcessing ? 'Processing...' : 'Confirm & Generate WebP'}
                      </button>
                       <button
                        onClick={resetState}
                        title="Upload a different image"
                        className="w-full sm:w-auto flex items-center justify-center gap-2 px-6 py-4 bg-gray-700 text-white font-semibold rounded-lg shadow-md hover:bg-gray-600 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-gray-500"
                      >
                        <RefreshIcon className="w-5 h-5" />
                        <span>New Image</span>
                      </button>
                    </div>

                    {Object.keys(croppedImages).length > 0 && (
                      <section className="bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-700">
                        <h2 className="text-2xl font-bold mb-6 text-center text-white">Generated Results</h2>
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                          {dynamicTargets.map(target => {
                            const currentScale = targetScales[target.id] || 1;
                            const outputWidth = Math.round(target.width * currentScale);
                            const outputHeight = Math.round(target.height * currentScale);
                            
                            return croppedImages[target.id] && (
                              <div key={target.id} className="flex flex-col items-center gap-4 p-6 bg-gray-900 rounded-lg border border-gray-700">
                                <div className="text-center">
                                    <h3 className="text-lg font-medium text-indigo-300">
                                      {target.label ? `${target.label}` : ''}
                                    </h3>
                                    <p className="text-sm text-gray-400 mt-1">
                                      {outputWidth} × {outputHeight} px
                                    </p>
                                    <p className="text-sm text-gray-400">
                                      {formatFileSize(croppedImages[target.id].size)}
                                    </p>
                                </div>
                                
                                <div className="relative overflow-hidden rounded-md border-2 border-gray-600 bg-black shadow-lg">
                                   <img 
                                      src={croppedImages[target.id].url} 
                                      alt={`Cropped ${outputWidth}x${outputHeight}`} 
                                      className="max-w-full h-auto"
                                      style={{ maxHeight: '300px' }} 
                                   />
                                </div>
                                <a
                                  href={croppedImages[target.id].url}
                                  download={getOutputFilename(imageInfo.name, target, currentScale)}
                                  className="w-full flex items-center justify-center gap-2 px-4 py-3 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-green-500 mt-2"
                                >
                                  <DownloadIcon className="w-5 h-5" />
                                  <span>Download {getOutputFilename(imageInfo.name, target, currentScale)}</span>
                                </a>
                              </div>
                            );
                          })}
                        </div>
                      </section>
                    )}
                  </div>
                )}
              </main>
            </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
